分两条线来看：
1是消息发送方在调用GtSendMsg()后，消息队列是怎么生成的；
2是系统是如何处理消息队列的（调用回调函数来处理）

1、GtSendMsg()函数
void GtSendMsg(GtMsgTarget dst, void *data, gt_u32 len)
{
    gt_assert(dst < TGT_MAX);
    gt_assert(data != NULL);
    gt_assert(len > 0);

    size_t size = len + sizeof(GtMsgNQNode);
    GtMsgNQNode *node = (GtMsgNQNode *)gt_malloc(size);
    if (node != NULL) {
        size_t offset = sizeof(dynamic_queue_entry_header) + sizeof(gt_u32);
        (void)memcpy_s(&node->msg, size - offset, data, len);
    } else {
        gt_assert(0);
    }
    ndynamic_task_queue qHandle = GtGetTaskQueueHandle(dst);//1.1
    if (!ndynamic_task_queue_send(qHandle, node)) {//1.2
        gt_assert(0);
    }
}
1.1、GtGetTaskQueueHandle()
ndynamic_task_queue GtGetTaskQueueHandle(GtMsgTarget target)
{
    GtTask type = g_gtTaskProcMap[target].type;
    gt_u8 index = g_gtTaskProcMap[target].procIndex;

    return g_gtTasks[type].queue_handle[index];
}
	这里用到的两个数据结构之前已经解释过了，函数返回的就是一个消息队列，如果这个消息队列是第一次创建，则返回值会是NULL，如果之前创建过，返回的就是之前创建的那个消息队列。
1.2、ndynamic_task_queue_send()
gt_bool ndynamic_task_queue_send(ndynamic_task_queue tq, gt_void* payload)
{
    gt_bool success = GT_TRUE;

    if (ndynamic_task_queue_send_helper(tq, payload, GT_FALSE)) { //1.2.1
        if (tq->task_to_notify != NULL) {
            if (!xTaskNotify(tq->task_to_notify, 0, eNoAction)) { //FreeRTOS中的函数，用于任务通知
                success = GT_FALSE;
            }
        }
    }

    return success;
}
1.2.1、ndynamic_task_queue_send_helper()
static gt_bool ndynamic_task_queue_send_helper(ndynamic_task_queue tq, gt_void* payload, gt_bool send_to_front)
{
    if (tq == NULL) {
        return GT_FALSE;
    }

    dynamic_queue_entry_header* elem = NULL;
    gt_bool success = GT_FALSE;

    ASSERT(payload != NULL);
    elem = (dynamic_queue_entry_header*)payload; /*lint !e838 Codemars requires elem initialising, lint disagrees */

    if (elem != NULL) { /*lint !e774  Always true if NQUEUE_SUPPPORT_NO_PAYLOAD_QUEUE_ENTRY_HEADER not defined*/

        taskENTER_CRITICAL();
        tq->num_items++;
        if (tq->head) {
            if (send_to_front) {
                elem->next = tq->head;
                tq->head = elem;
            } else {
                elem->next = NULL;
                tq->tail->next = elem;
                tq->tail = elem;
            }
        } else {
            elem->next = NULL;
            tq->head = elem;
            tq->tail = elem;
        }
        taskEXIT_CRITICAL();
        success = GT_TRUE;
    }

    return success;
}
	这里就是在进行任务队列的配置，代码大致过程为：
首先会新创建一个任务；
如果任务队列是空的，就任务队列的队首和队尾指针都指向这个新创建的任务；
如果任务队列不是空的：
如果要把任务插到队首，就执行队首插入；
如果不要求把任务插到队首，就把任务插到队尾。

	至此，从消息发送方调用GtSendMsg()，到把任务加入到任务队列的过程就是这样，任务队列可以通过最初的那个数据结构g_gtTasks获取，且g_gtTasks中还包含与任务队列相关的回调函数。

2、GtStartAllTask()
void GtStartAllTask()
{
    gt_u8 i = 0;
    for (; i < TASK_MAX; ++i) {// TASK_MAX==7，代表7种任务，目前每种任务只有一个任务队列。
        GtTaskInst *task = &g_gtTasks[i];
        GtCreateTaskQueue(task);
        GtTaskPreProc(task);
        BaseType_t ret = xTaskCreate(GtTaskRunner,             /* task runner*/
                                     task->name,               /* task name */
                                     task->stackSize,          /* task stack size */
                                     &(task->type),            /* task runner parameter */
                                     task->priority,           /* task priority */
                                     (struct tskTaskControlBlock ** const)(&task->task_handle)); /* task handle */
        if (ret != pdPASS) {
            gt_assert(0);
        }
    }
}
	这是启动所有任务的一个函数，函数主要是循环处理所有任务队列中任务，任务处理函数是GtTaskRunner。

2.1、GtTaskRunner()
void GtTaskRunner(void *param)
{
    GtTask *type = (GtTask *)param;
    osThreadId_t taskHandle = osThreadGetId();
    GtTaskInst *task = &g_gtTasks[*type];

    NDYNAMIC_QUEUE_CALLBACK *callbacks = (NDYNAMIC_QUEUE_CALLBACK *)gt_malloc(task->qNum * sizeof(NDYNAMIC_QUEUE_CALLBACK));
    if (callbacks == NULL) {
        gt_assert(0);
        return;
    }

    GtTaskContext **contexts = (GtTaskContext **)gt_malloc(task->qNum * sizeof(GtTaskContext *));
    if (contexts == NULL) {
        gt_assert(0);
        return;
    }

    gt_u8 i;
    for (i = 0; i < task->qNum; ++i) { // task->qNum目前都是1
        if (!ndynamic_task_queue_set_task_to_notify(task->queue_handle[i], taskHandle)) {
            gt_assert(0);
            return;
        }
        callbacks[i] = GtRecv; //2.1.1
        contexts[i] = (GtTaskContext *)gt_malloc(sizeof(GtTaskContext));
        if (contexts[i] == NULL) {
            gt_assert(0);
            return;
        }
        contexts[i]->type = *type;
        contexts[i]->index = i;
    }

    ndynamic_task_queue_group_receive_processor(task->qNum, task->queue_handle, (gt_void * const *)contexts, callbacks); //2.1.2
}

2.1.1、GtRecv
void GtRecv(void *context, void *data)
{
    GtMsgNQNode *node = (GtMsgNQNode *)data;
    GtTaskContext *contextInfo = (GtTaskContext *)context;
    GtMsgHeader *msg = &node->msg;

    GtMsgRecvCb cb = g_gtTasks[contextInfo->type].callBacks[contextInfo->index]; //这里就找到了任务对应的回调函数
    gt_assert(cb != NULL);
    cb(msg, msg->len); //在这里调用回调函数，至此为止我们知道，只要callbacks[i]被执行，就等同于GtRecv被执行，就等同于调用了回调函数处理消息。

    gt_free(node);
}

2.1.2、ndynamic_task_queue_group_receive_processor
void ndynamic_task_queue_group_receive_processor(gt_u32 num_queues, const ndynamic_task_queue *tqs,
                                                 gt_void * const *contexts, const NDYNAMIC_QUEUE_CALLBACK *callbacks)
{
    osThreadId_t current_task_handle = (osThreadId_t) xTaskGetCurrentTaskHandle();

    for (gt_u32 i = 0; i < num_queues; i++) {
        check_queue_and_callbacks_valid(i, tqs, callbacks, current_task_handle);
    }

    while (1) { /*lint !e716 */
        gt_bool searching = GT_TRUE;
        (void) xTaskNotifyWait(0, 0, NULL, portMAX_DELAY);

        while (searching) {
            /* Starting at the highest priority queue, look for a message to consume */
            searching = find_message_to_consume(num_queues, tqs, contexts, callbacks); //2.1.2.1
        }
    }
}

2.1.2.1 find_message_to_consume
static gt_bool find_message_to_consume(gt_u32 num_queues, const ndynamic_task_queue *tqs,
                                       gt_void * const *contexts, const NDYNAMIC_QUEUE_CALLBACK *callbacks)
{
    /* Starting at the highest priority queue, look for a message to consume */
    gt_bool searching = GT_FALSE;
    gt_u32 index;
    dynamic_queue_entry_header *elem = NULL;
    void* payload = NULL;

    for (index = 0; index < num_queues; index++) {
        /* Get the indicated queue from the queue set */
        ndynamic_task_queue tq = tqs[index];

        /* See if this queue contains anything */
        if (tq->head) {
            /* An item has been found, so keep searching when this one has completed */
            searching = GT_TRUE;
            taskENTER_CRITICAL();
            /* Get the elem from the queue */
            elem = tq->head;

            /* move the queue on */
            tq->head = tq->head->next;
            tq->num_items--;

            /* Clear tail if necessary */
            if (!tq->head) {
                tq->tail = NULL;
            }
            taskEXIT_CRITICAL();

            payload = (void*)elem;

            /* Collect the callback and context for this queue */
            NDYNAMIC_QUEUE_CALLBACK callback = callbacks[index];
            void *context = NULL;
            if (contexts != NULL) {
                context = contexts[index];
            }

            callback(context, payload); //至此，就看到了回调函数被调用执行

            /** Break out of the for loop - in case a higher-priority
             *  message arrived while this one was being processed.
             *  This will go back to the "while (searching)" loop.
             */
            break;
        }
    }
    return searching;
}
	到此为止，也就看到了整个的任务队列处理的过程。


