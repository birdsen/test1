MAC层TARGET_MAC_DLSCH模块内函数流程
1、入口文件gt_mac_dl_msg.c中的入口函数根据消息来源的不同，交给不同的子模块去处理，入口函数如下所示
void GtMacDlProcMsg(void *msg, gt_u16 len)
{
    GtL2MsgHeader *head = (GtL2MsgHeader *)msg;

    GtL2MsgTarget srcTarget = head->src;
    GtL2MsgTarget dstTarget = head->dst;
    gt_u16 type = head->type;

    GT_DEBUG_DLSH("GtMacDlProcMsg default srcTarget:%d, dstTarget:%d, type:%d\r\n", 
        head->src, head->dst, head->type);
            
    gt_assert(dstTarget == TARGET_MAC_DLSCH);

    switch (srcTarget) {
        case TARGET_TNM: {
            GtMacDlProcXrc(msg, len);
            break;
        }
        case TARGET_ITF_STACK: {
            GtMacDlProcItfStack(msg, len);
            break;
        }
        default: {
            GT_DEBUG_DLSH("GtMacDlProcMsg default srcTarget:%d, dstTarget:%d, type:%d\r\n", 
                head->src, head->dst, head->type);
            gt_assert(0);
            break;
        }
    }
}
2.1、如果消息来自TARGET_TNM，就调用gt_mac_dl_xrc.c文件中的入口函数GtMacDlProcXrc来处理，入口函数如下所示：
void GtMacDlProcXrc(void *msg, gt_u16 len)
{
    gt_u16 type = ((GtL2MsgHeader *)msg)->type;
    switch (type) {
        case MSG_SPS_REPORT: {
            GtMacDlProcSpsReport(msg, len);
            SpsDlPrintResInfo();
            SpsDlPrintFreqInfo();
            break;
        }
        case MSG_SPS_NOTIFY_ACTIVE: {
            GtMacDlProcSpsNotifyActive(msg, len);
            break;
        }
        case MSG_SPS_NOTIFY_DEACTIVE: {
            GtMacDlProcSpsNotifyDeActive(msg, len);
            break;
        }
        case L3_MGM_CELL_SETUP_REQ: {
            GtMacCellSetupReq(msg, len);
            break;
        }
        case L3_MGM_CELL_RECFG_REQ: {
            GtMacCellReCfgReq(msg, len);
            break;
        }
        case L3_MGM_CELL_DEL_REQ: {
            GtMacCellDelReq(msg, len);
            break;
        }
        case L3_MGM_SYSTEM_INFO_UPDATE_REQ: {
            GtMacSysInfoUpdateReq(msg, len);
            break;
        }
        default : {
            GT_DEBUG_DLSH("GtMacDlProcXrc default srcTarget:%d, dstTarget:%d, type:%d\r\n", 
                ((GtL2MsgHeader *)msg)->src, ((GtL2MsgHeader *)msg)->dst, ((GtL2MsgHeader *)msg)->type);
            break;
        }
    }
}
该入口函数根据消息类型的不同，调用不同的子函数去处理，详情如下
2.1.1、case MSG_SPS_REPORT: {
            GtMacDlProcSpsReport(msg, len);
            SpsDlPrintResInfo();
            SpsDlPrintFreqInfo();
            break;
        }
	其中，GtMacDlProcSpsReport()用于处理半静态的T节点的业务特征上报，该函数调用了gt_mgm.c中的GtMgmGetSpsTNodeStatus()函数来判断T节点是否存在且处于激活状态，如果处于非激活状态，就调用gt_l2_base.c中的GtGetRealSamplingRate()函数和GtGetRealSamplingLen()函数来根据上报信息中对应的采样率和采样位宽得到相应的采样率和采样位宽，再调用gt_mac_dl_sps.c中的SpsDlCalcRes()函数计算配置的资源，再调用gt_mgm.c中的GtMgmUpdateSpsTNode ()，利用上述配置信息更新、创建T节点，最后调用本文件中的GtMacDlSendXrcTNodeResCfg()函数来转换 XRC 资源配置信令消息, 该函数调用了gt_l2_start.c中的GtL2FillMsgHeader()函数来配置消息头，最后调用gt_l2_start.c中的GtL2SendMsg()函数来将消息发给TNM模块。
	剩下的两个函数都是gt_mac_dl_sps.c中的函数，用于打印当前的时频域分配信息。
2.1.2、case MSG_SPS_NOTIFY_ACTIVE: {
            GtMacDlProcSpsNotifyActive(msg, len);
            break;
        }
	其中，GtMacDlProcSpsNotifyActive()函数位于本文件中，它调用了gt_mac_dl_sps.c中的SpsDlActiveDciMul()来下发激活DCI。
2.1.3、case MSG_SPS_NOTIFY_DEACTIVE: {
            GtMacDlProcSpsNotifyDeActive(msg, len);
            break;
        }
	其中，GtMacDlProcSpsNotifyDeActive()函数位于本文件中，它调用了gt_mac_dl_sps.c中的SpsDlDeActiveDciMul()来下发去激活DCI。
2.1.4、case L3_MGM_CELL_SETUP_REQ: {
            GtMacCellSetupReq(msg, len);
            break;
        }
	其中，GtMacCellSetupReq()函数位于本文件中，它调用了gt_mgm.c中的GtMgmFillCellInfo()函数，又调用了gt_l2_start.c中的GtL2FillMsgHeader()函数来配置消息头，最后调用gt_l2_start.c中的GtL2SendMsg()函数来将消息发给TNM模块。
2.1.5、case L3_MGM_CELL_RECFG_REQ: {
            GtMacCellReCfgReq(msg, len);
            break;
        }
	其中，GtMacCellReCfgReq()函数位于本文件中，它的调用关系同上。
2.1.6、case L3_MGM_CELL_DEL_REQ: {
            GtMacCellDelReq(msg, len);
            break;
        }
	其中，GtMacCellDelReq()函数位于本文件中，它调用了gt_mgm.c中的GtMgmClearCellInfo()函数，又调用了gt_l2_start.c中的GtL2FillMsgHeader()函数来配置消息头，最后调用gt_l2_start.c中的GtL2SendMsg()函数来将消息发给TNM模块。
2.1.7、case L3_MGM_SYSTEM_INFO_UPDATE_REQ: {
            GtMacSysInfoUpdateReq(msg, len);
            break;
        }
	其中，GtMacSysInfoUpdateReq()函数位于本文件中，它调用了gt_mgm.c中的GtMgmFillSysInfo ()函数，又调用了gt_l2_start.c中的GtL2FillMsgHeader()函数来配置消息头，最后调用gt_l2_start.c中的GtL2SendMsg()函数来将消息发给TNM模块。


2.2、如果消息来自TARGET_ITF_STACK，就调用gt_mac_dl_itf_stack.c文件中的入口函数来处理，入口函数如下所示：
void GtMacDlProcItfStack(void *msg, gt_u16 len)
{
    gt_u16 type = ((GtL2MsgHeader *)msg)->type;
    switch (type) {
        case MSG_ITF_SPS_ACTIVE_DCI_ACK: {
            GtMacDlProcSpsActiveDciAck(msg, len);
            break;
        }
        case MSG_ITF_SPS_DEACTIVE_DCI_ACK: {
            GtMacDlProcSpsDeActiveDciAck(msg, len);
            break;
        }
        default : {
            break;
        }
    }
}
入口函数根据消息的类型不同，调用本文件下的不同函数去处理，详情如下：
2.2.1、case MSG_ITF_SPS_ACTIVE_DCI_ACK: {
            GtMacDlProcSpsActiveDciAck(msg, len);
            break;
        }
	其中，GtMacDlProcSpsActiveDciAck()函数依次调用：
（1）本文件中的GtMacDlGetSpsActiveAckNodes()函数：获取SPS激活Ack中节点集合, 这里模拟 1, 2 节点(TODO)
（2）gt_mgm.c中的GtMgmSetSpsTnodesStatus()函数：通过gt_mgm.c中的GtMgmFindSpsTNodeById()函数获取参数中指定的每一个T节点（即上一步中的SPS激活Ack中节点集合），并更新该T节点状态。
（3）gt_dci.c中的GtDciCalcCommonRes()函数来计算DCI资源。
（4）gt_mac_dl_sps.c中的SpsDlRefreshType2ResInd()函数来刷新第二类数据信息传输开销资源指示信息，并通过DCI下发。
2.2.2、case MSG_ITF_SPS_DEACTIVE_DCI_ACK: {
            GtMacDlProcSpsDeActiveDciAck(msg, len);
            break;
        }
	其中，GtMacDlProcSpsDeActiveDciAck()函数依次调用：
（1）本文件中的GtMacDlGetSpsDeActiveAckNodes()函数：获取SPS去激活Ack中节点集合, 这里模拟 1, 2 节点(TODO)
（2）本文件中的GtMacDlProcTnodesDeActive()函数：通过gt_mgm.c中的GtMgmFindSpsTNodeById()函数获取参数中指定的每一个T节点（即上一步中的SPS激活Ack中节点集合），并更新该T节点状态和调用gt_mgm.c中的GtMgmClearSpsTNodeUsedRes()函数清空 T 节点占用的时频资源，最后调用本文件中的GtMacDlNotifyLcSpsDataStop()函数通知 LC 停止发送 SPS 数据，其中，GtMacDlNotifyLcSpsDataStop()函数调用了gt_l2_start.c中的GtL2FillMsgHeader()函数来配置消息头，最后调用gt_l2_start.c中的GtL2SendMsg()函数来将消息发给TARGET_LC_DL模块。
（3）gt_mac_dl_dyns.c中的GtRefreshType2Resource()函数来刷新动态调度资源，
（4）然后就是这俩函数：
    SpsDlPrintResInfo()
    SpsDlPrintFreqInfo()


