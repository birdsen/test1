
关于任务调度：
1、l2层的每个模块以消息msg作为输入，msg中不仅包含了消息本身，还包含消息的源和目的、消息类型。msg中标识的dst即为自己，模块根据msg中标识的src不同来调用不同的子模块来处理。子模块可能会发消息来调用别的模块继续下去。比如ift模块的调度文件gt_itf.c中，它的入口函数是GtStackProcMsg()，这个入口函数的身份（也即调用该函数时传入的msg中的dst字段）就是TARGET_ITF_STACK。
2、如上所述，l2层各模块之间是通过发送消息来交互的，比如GtL2SendMsg(TARGET_TNM, &resCfgMsg, len);，就表示把消息resCfgMsg发给目标TARGET_TNM，每一个目标都有不同的结构体成员来标识。gt_l2_start.c是整个l2层的调度文件，其中包含的GtL2SendMsg被各子模块来调用。
3、发送消息的函数是void GtL2SendMsg(GtL2MsgTarget dst, void *data, gt_u32 len)，其中dst指定了消息要发给谁。该函数首先会包装一下即将发送的数据data，然后调用子模块来根据dst生成一个句柄，这个句柄中包含了身份为dst的模块的回调函数，比如GtStackProcMsg()，然后用这个句柄和包装后的数据来调用任务队列处理函数来执行任务。


以G节点时序图中第一类SPS激活流程（下行）的第二步，即TNM收到SPS业务特征上报后向DLSCH发消息的过程来阐述上述调度机制：
1.1 tnm_msg.c中的GtTnmProcMsg()函数在收到业务特征上报消息后开始执行（被调用），执行的逻辑就是：收到消息之后应该调用哪个子模块去处理
void GtTnmProcMsg(void *msg, gt_u16 len)
{
    GtL2MsgHeader *head = (GtL2MsgHeader *)msg;

    GtL2MsgTarget srcTarget = head->src;
    GtL2MsgTarget dstTarget = head->dst;
    gt_u16 type = head->type;

    gt_assert(dstTarget == TARGET_TNM);//这反应了GtTnmProcMsg()函数就代表了TARGET_TNM模块。

    switch (srcTarget) {//根据msg中的src字段的不同，调用不同的子模块来处理。
        case TARGET_MAC_DLSCH: { 
            GtTnmProcMacDlMsg(msg, len); //调用同级目录下的tnm_mac_dl.c文件中的函数去处理
            break;
        }
        case TARGET_ITF_STACK: {
            GtTnmProcItfMsg(msg, len); //调用同级目录下的tnm_itf_stack.c文件中的函数去处理
            break;
        }
        default: {
            gt_assert(0);
            break;
        }
    }
}
1.2 现在任务来到了tnm_itf_stack.c文件中GtTnmProcItfMsg()函数，该函数将根据msg中的类型字段来判定消息类型，进而调用不同的函数来处理
void GtTnmProcItfMsg(void *msg, gt_u16 len)
{
    gt_u16 type = ((GtL2MsgHeader *)msg)->type;
    switch (type) {//根据msg中的类型字段来判定消息类型
        case MSG_TNM_SERVICE_REPORT: {
            // 消息类型是“T节点业务特征上报”，所以调用本文件的相关函数来处理
            GtTnmProcTnodeReport(msg, len);
            break;
        }
        case MSG_TNM_SPS_RES_CONF_ACK: {
            // 消息类型是“资源分配成功 ACK” ，所以调用本文件的相关函数来处理
            GtTnmProcTnodeResCfgAck(msg, len);
            break;
        }
        default : {
            break;
        }
    }
}
1.3 现在任务来到了tnm_itf_stack.c文件中GtTnmProcTnodeReport()函数，该函数对msg中的信息进行提取、包装，然后把包装后的信息通过GtL2SendMsg函数以发消息的形式交给TARGET_MAC_DLSCH模块去处理。
void GtTnmProcTnodeReport(void *msg, gt_u16 len)
{
    // 模拟接收上报的业务特征
    GtTnmSamplingMsg *msgTest = (GtTnmSamplingMsg *)msg;
    GT_DEBUG("tnm recv report msg : tnode %ld type %d samplingRate %d samplingLen %d\n",
            msgTest->id,
            msgTest->header.type,
            msgTest->sampling.rate,
            msgTest->sampling.len);
    // 发给MAC DL
    GtSpsReportMsg report;
    report.header.type = MSG_SPS_REPORT;
    report.header.src = TARGET_TNM;
    report.header.dst = TARGET_MAC_DLSCH;
    report.header.len = sizeof(GtSpsReportMsg);
    report.id = msgTest->id;
    report.rate = msgTest->sampling.rate;
    report.len = msgTest->sampling.len;
    GtL2SendMsg(TARGET_MAC_DLSCH, &report, sizeof(GtSpsReportMsg));
}
至此，业务特征上报TNM侧的处理已经完成，接下来就要来到DLSCH侧的处理了，这里有几点说明一下：
（1）xrc文件夹下包括gnm和tnm两个子文件夹，表示了tnm模块是xrc层的一个模块，后面看到的函数命名，比如gt_mac_dl_xrc.c就表示该文件是和xrc对接的，会发消息给xrc（gt_mac_dl_xrc.c由gt_mac_dl_msg.c支配）
（2）DLSCH模块也就是TARGET_MAC_DLSCH，它就是mac文件夹下gt_mac_dl_msg.c文件中的GtMacDlProcMsg()函数，该函数的执行过程和1.1类似，这里就不去追踪后续了，这里关心的是，GtL2SendMsg是怎么把消息发给目标的，怎么调度起来的，这关系到整个l2层内部的itf、mac、lc、xrc之间是如何配合的。
>实际开发中只需要知道发消息给谁处理就可以了，至于GtL2SendMsg()做了什么，怎么把消息发给相应的模块的，实际开发子模块的时候不会去关心，但是GtL2SendMsg()函数是l2层调度文件中的一个核心函数，它是各子模块沟通的桥梁。
2.1 下面了解l2文件夹下的gt_l2_start.c文件中的GtL2SendMsg()函数的调度机制，该函数首先把参数2，即传入的消息data处理、包装成变量node，然后根据参数1获取句柄，最后将句柄和node一并传入调度函数去处理。
void GtL2SendMsg(GtL2MsgTarget dst, void *data, gt_u32 len)
{
    gt_assert(dst < TARGET_MAX);
    gt_assert(data != NULL);
    gt_assert(len > 0);

    size_t size = len + sizeof(GtMsgNQNode);
    GtMsgNQNode *node = (GtMsgNQNode *)gt_malloc(size);
    if (node != NULL) {
        size_t offset = sizeof(dynamic_queue_entry_header) + sizeof(gt_u32);
        (void)memcpy_s(&node->msg, size - offset, data, len);
    } else {
        gt_panic(GT_MALLOC_FAIL, size);
    }
    ndynamic_task_queue qHandle = GtL2GetTaskQueueHandle(dst);
    if (!ndynamic_task_queue_send(qHandle, node)) {
        gt_assert(0);
    }
}
msg如何处理的暂不关心，目前关心的是怎么找到目标模块的。下面先看句柄的处理。
2.2 先看GtL2GetTaskQueueHandle()函数是如何获取句柄的。
ndynamic_task_queue GtL2GetTaskQueueHandle(GtL2MsgTarget target)
{
    GtL2Task type = g_gtTaskProcMap[target].type;
    gt_u8 index = g_gtTaskProcMap[target].procIndex;

    return g_gtL2Tasks[type].queue_handle[index];
}
上面主要包括两个数据结构，一个是g_gtTaskProcMap数组，一个是g_gtL2Tasks数组，先看第一个
2.2.1 g_gtTaskProcMap的定义如下
GtL2TaskProcMap g_gtTaskProcMap[TARGET_MAX] = {
    {TARGET_GNM,       L2_TASK_GNM,         0},
    {TARGET_TNM,       L2_TASK_TNM,         0},
    {TARGET_LC_DL,     L2_TASK_LC_DL,       0},
    {TARGET_LC_UL,     L2_TASK_LC_UL,       0},
    {TARGET_MAC_DLSCH, L2_TASK_MAC_DLSCH,   0},
    {TARGET_DMAC_DL,   L2_TASK_DMAC_DL,     0},
    {TARGET_DMAC_UL,   L2_TASK_DMAC_UL,     0},
    {TARGET_UL_SCH,    L2_TASK_UL_SCH,      0},
    {TARGET_MAC_UL,    L2_TASK_MAC_UL,      0},
    {TARGET_ITF_DSP,   L2_TASK_ITF,         0},
    {TARGET_ITF_RF,    L2_TASK_ITF,         1},
{TARGET_ITF_STACK, L2_TASK_ITF,         2}
};
其中，类型GtL2TaskProcMap的定义如下
typedef struct {
    GtL2MsgTarget target;
    GtL2Task type;
    gt_u8 procIndex;
} GtL2TaskProcMap;
从上面两个结构体中反应了两个信息：
（1）消息传递和调度过程中定义了两种“身份信息”（枚举类型）： GtL2MsgTarget表示消息类型，在消息传递中使用，GtL2Task表示任务类型，在调度过程中使用。两种类型存在一一对应的关系（除了itf）。
（2）回到2.2，使用g_gtTaskProcMap的目的就是根据消息类型来获取对应的任务类型和procIndex（该字段含义还没明白）。
从g_gtTaskProcMap数组中获取的结果传入到了g_gtL2Tasks数组中使用，接下来看g_gtL2Tasks数组
2.2.2 g_gtL2Tasks数组的定义如下
GtL2TaskInst g_gtL2Tasks[L2_TASK_MAX] = {
    {L2_TASK_GNM,       GT_TASK_GNM_PRIORITY,        GT_TASK_GNM_STACK_SIZE,        "gnm",     NULL, 1, NULL, g_gnmMsgRecv},
    {L2_TASK_TNM,       GT_TASK_TNM_PRIORITY,        GT_TASK_TNM_STACK_SIZE,        "tnm",     NULL, 1, NULL, g_tnmMsgRecv},
    {L2_TASK_LC_DL,     GT_TASK_LC_DL_PRIORITY,      GT_TASK_LC_DL_STACK_SIZE,      "lc_dl",   NULL, 1, NULL, g_lcDlMsgRecv},
    {L2_TASK_LC_UL,     GT_TASK_LC_UL_PRIORITY,      GT_TASK_LC_UL_STACK_SIZE,      "lc_ul",   NULL, 1, NULL, g_lcUlMsgRecv},
    {L2_TASK_MAC_DLSCH, GT_TASK_MAC_DL_PRIORITY,     GT_TASK_MAC_DL_STACK_SIZE,     "mac_dl",  NULL, 1, NULL, g_macDlSchMsgRecv},
    {L2_TASK_DMAC_DL,   GT_TASK_DMAC_DL_PRIORITY,    GT_TASK_DMAC_DL_STACK_SIZE,    "dmac_dl", NULL, 1, NULL, g_dmacDlMsgRecv},
    {L2_TASK_DMAC_UL,   GT_TASK_DMAC_UL_PRIORITY,    GT_TASK_DMAC_UL_STACK_SIZE,    "dmac_ul", NULL, 1, NULL, g_dmacUlMsgRecv},
    {L2_TASK_UL_SCH,    GT_TASK_ULSH_PRIORITY,       GT_TASK_ULSH_STACK_SIZE,       "ulsh",    NULL, 1, NULL, g_ulshMsgRecv},
    {L2_TASK_MAC_UL,    GT_TASK_MAC_UL_PRIORITY,     GT_TASK_MAC_UL_STACK_SIZE,     "mac_ul",  NULL, 1, NULL, g_macUlMsgRecv},
    {L2_TASK_ITF,       GT_TASK_ITF_PRIORITY,        GT_TASK_ITF_STACK_SIZE,        "itf",     NULL, 3, NULL, g_itfMsgRecv},
};
其中，类型GtL2TaskInst的定义如下
typedef struct {
    GtL2Task type;//任务类型
    gt_u16 priority;
    gt_u16 stackSize;
    const char *const name;
    osThreadId_t task_handle;           // 任务句柄
    gt_u32 qNum;                        // 队列数目
    ndynamic_task_queue *queue_handle;  // 消息队列
    GtL2MsgRecvCb *callBacks;           // 任务消息处理回调
} GtL2TaskInst;
上面两个结构体反应了：
（1）2.2.1中我们根据消息类型TARGET_MAC_DLSCH得到了任务类型L2_TASK_MAC_DLSCH，现在根据任务类型来看对应于g_gtL2Tasks数组中的哪一项，发现该项对应的任务消息处理回调是g_macDlSchMsgRecv，它在本文件中声明如下：
extern GtL2MsgRecvCb g_macDlSchMsgRecv[];
然后在gt_mac_dl_msg.c中定义了
	GtL2MsgRecvCb g_macDlSchMsgRecv[] = {
    	GtMacDlProcMsg,//这就是1.3中提到的DLSCH模块的处理函数
};
至此我们明确了GtL2SendMsg()会根据dst找到对应的目标模块的回调函数，后续会启动任务调度队列相关的程序。

