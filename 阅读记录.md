0、HARQ实现了什么
1、每一个T节点都有4个上行和4个下行HARQ进程，DL过程下，DLSCH发来调度信息msg给DMAC_DL，msg包含了对多个T节点的调度信息，以及每个T节点的调度类型（新传或重传），DMAC_DL收到msg后依次处理每个T节点的调度，对每个T节点，如果是新传，DMAC_DL就通知LC组包，然后在把数据包发给ITF之前将该数据交给DLSCH指定的该T节点的HARQ进程的缓存里保存，如果是重传，就从DLSCH指定的HARQ进程的缓存中取回来发给ITF，重传次数由HARQ进程维护。
2、DMAC_DL里面处理的HARQ都是动态调度的数据，与SPS无关，但DMAC_UL里面处理的HARQ有SPS。
3、目前了解的HARQ模块的作用主要就是：如果要新传数据，就在相应的HARQ进程里面保存一份，如果要重传数据，就从相应的HARQ进程取，总的来看HARQ模块的一个主要功能就是维护HARQ缓存中的数据（包括维护数据重传的次数）。

0、现在问题是，UL过程时，T节点发来的ACK是交给谁处理的（是不是DLSCH）。

0、看一下HARQ.c
	文件包含两个上下行共用的函数，
（1）void GtHarqInit(HarqInfo *info)：HARQInfo及HARQBuffer初始化 上下行共用。
	其中，
typedef struct tagHarqInfo {
    HarqInfoDl harqInfoDl[TOL_PROC_NUMS]; //下行HARQInfo, 共4个进程
    HarqInfoUl harqInfoUl[TOL_PROC_NUMS]; //上行HARQInfo, 共4个进程
    gt_u8 **harqBuffer;      //Buffer的大小为: TOL_PROC_NUMS*15000 Byte
} HarqInfo;
（2）void GtHarqDlBufferFree(HarqInfo *info)：HARQBuffer释放
（3）void GtHarqDlDmacInfoUpd(HarqInfo *info, gt_u8 procNum, GtHarqAckType ackState)：该函数用来对G节点中维护的某个指定T节点的HARQ进程的信息进行刷新，具体包括：
>>根据info->harqInfoDl[procNum].txTimes判断是否达到最大重传次数，如果达到，则重置info->harqInfoDl[procNum]下的所有信息，即该T节点的procNum号HARQ进程变成闲置状态；
>>如果没有达到最大重传次数，则根据ackState判断ack类型：如果是ACK，也重置info->harqInfoDl[procNum]下的所有信息，如果是NACK，则info->harqInfoDl[procNum].ackType = NACK; info->harqInfoDl[procNum].waitTimes++; ，如果是DTX（ACK漏检），则分情况，如果是初传，则ackType记录为 DTX，同时waitTimes++，如果是重传，则ackType记录为NACK，同时也waitTimes++（waitTimes表示等待时间，收到NACK/DTX反馈后开始计时，每超帧取值+1，当达到最大值后，从0开始重新计数，同时重传次数+1）

该函数在gt_dmac_ul_msg.c中用到，在其中的GtDlSetHarqAck(UeAckFbackInfoStru *msg)函数中处理上行ACK消息时被调用，GtDlSetHarqAck()函数用来找到msg中指定的T节点，然后就是调用本函数刷新T节点的HARQ进程的信息。GtDlSetHarqAck()被GtItfDmacUlAckFeedBackProc()调用，GtItfDmacUlAckFeedBackProc()用来处理msg中包含的所有T节点的SPS业务的ack反馈，对于每一个T节点的反馈，都调用GtDlSetHarqAck()处理。
（4）void GtHarqUlDmacInfoUpd(HarqInfo *info, gt_u8 procNum, GtHarqAckType ackState)：和上述函数类似，只不过这里更新的是info->harqInfoUl[procNum]下的信息，上面更新的是info->harqInfoDl[procNum]下的信息。然后就是，这里没有DTX的处理。
该函数的使用场景和上面的函数一样，该函数在上面的函数调用后立刻调用。
（该函数更新的T节点是通过该语句获取的：TNodeUl *nodeul = GtMgmUlFindTNodeById(msg->GNodeUeId); ，语句中的函数是gt_ul_mgm.c中的函数，他们分别维护了下行的T节点信息和上行的T节点信息，gt_ul_mgm.c中的函数支撑了mac-ul文件夹下的多个文件，所以为什么分别维护了下行的T节点信息和上行的T节点信息要看ul侧的实现）
（5）gt_u8 GtHarqDlGetIdleProcess(HarqInfo *info)：从info->harqInfoDl[]中找到空闲的HARQ进程。
	该函数在mgm.c中的GtMgmIsTnodeDynFirst(TNode *node)函数中被调用，用来找到T节点中的用于初传的动态调度的HARQ进程，GtMgmIsTnodeDynFirst ()被动态调度中的文件调用，用来给node配置用于初传的HARQ进程。
（6）gt_u8 GtHarqUlGetIdleProcess(HarqInfo *info)：从info->harqInfoUl[]中找到空闲的HARQ进程。
（7）gt_u8 GtHarqDlGetRetryIdleProcess(HarqInfo *info, GtHarqAckType *type, gt_u8 *txTimes)：找到指定T节点的下行HARQ进程中非空闲的（用于重传的）等待时间最长的且进程号最小的HARQ进程，以参数传出此HARQ进程的ackType和重传次数，并以返回值传出此HARQ进程的进程号。
	该函数在mgm.c中的GtMgmIsTnodeDynHarq(TNode *node)函数中被调用，用来找到T节点中的用于重传的动态调度的HARQ进程（区别于初传），GtMgmIsTnodeDynHarq()被动态调度中的文件调用，用来给node配置用于重传的HARQ进程。
（8）gt_u8 GtHarqUlGetRetryIdleProcess(HarqInfo *info, GtHarqAckType *type, gt_u8 *txTimes)：和上面的类似，是对称的。
（9）void GtHarqDlSchInfoUpd(HarqInfo *info, gt_u8 procNum, gt_u8 schSuccess, GTTransfType schType, gt_u16 tbSize, gt_u8 *lcData)：如果schType显示是新传，就把lcData中的数据拷贝至info指示的相应HARQ进程的缓存中，供后续重传时使用，如果是重传，就使重传次数+1。
	本函数在gt_dmac_dl_msg.c中处理重传数据和新传数据时调用。新传时在将数据交给ITF之前会调用该函数把新传的数据在HARQ进程中保存一份。
（10）void GtHarqUlSchInfoUpd(HarqInfo *info, gt_u8 procNum, gt_u8 schSuccess, gt_u8 schType)：如果是新传，就把对应的进程号置为非空闲，如果是重传，就使重传次数加一。
（11）void GtHarqDlReadBuf(HarqInfo *info, gt_u8 procNum, gt_u16 tbSize,  gt_u8 *harqBufferOut)：用于把保存在HARQ进程中的数据拷贝到harqBufferOut中去。
	本函数在重传时被调用，用于取回相应HARQ进程中的数据。



0、看一下随机接入（DMAC_UL里面）

