
// 下行调度资源分配表
GtResData g_gtSpsDlResourceData;
/*
typedef struct {
    gt_u8 frm[6]; // 48 bit，代表48个无线帧，即一个超帧，主要这里用二进制位来标记每一个无线帧
    gt_u8 reserved[2];
} GtFrmRes;

typedef struct {
    GtFrmRes data[GT_SUB_CARRI_MAX]; // 0-18 and 20-38
    gt_u8 usedCarriNum;
    gt_u8 reserved[3];
} GtResData;
*/

// 下行调度频域信息，每一个bit代表一个频域资源
gt_u8 g_gtSpsDlLastFreq[5];

//[.h] debug info，以一定格式输出g_gtSpsDlResourceData中的每个子载波的每个无线帧的分配情况（一堆0或1）
void SpsDlPrintResInfo(){}

//[.h] debug info，以一定格式输出g_gtSpsDlLastFreq中的频域资源分配情况（一堆0或1）
void SpsDlPrintFreqInfo(){}

//[.h] 发送公共DCI消息，在下面的SpsDlRefreshType2ResInd()中被调用，用来发送第二类资源指示DCI
void SpsDlSendCommonDciMsg(gt_u8 msgType, gt_u8 dciFormat, DciResBitMap *res){}

//[.h] 刷新第二类数据信息传输开销资源指示信息
void SpsDlRefreshType2ResInd(DciResBitMap *res){}

//根据采样率和量化位宽来计算tbSize（根据《GT技术RRM算法设计说明书》4.2.1.1节中的表格来实现）
（此处的量化位宽，即采样深度：即第一类业务每个采样时刻的信息bit数）
gt_u8 SpsCalcTbSizeBySrSl(SamplingRate sr, SamplingLen sl){}

//根据采样率来计算采样周期（也是根据上面提到的表格来实现）
gt_u8 SpsGetFramePeriodBySr(SamplingRate sr){}

//返回FrameOffset（首次分配资源的无线帧编号），该值也是根据上面提到的表格来确定，实际代码中返回的是0
gt_u8 SpsGetFrameOffsetBySr(SamplingRate sr){}

//计算频谱效率eff（代码中就是按照算法设计说明书来直接 return  srModulation * codeRate）
double SpsCalcSpectralEff(gt_u8 srModulation, double codeRate){}

//计算需要的频域子载波个数（也是根据算法设计说明书来计算的）
gt_u8 SpsCalcSubCarriCount(SpsInputParamType1 *param){}

//返回调制方式（调制阶数）
SrModulation SpsGetModulationByOrder(gt_u8 srModulationOrder){}

// 有可占用的时域资源即为空闲（检查g_gtSpsDlResourceData.data[index]子载波中有没有空闲的无线帧，只要有一个无线帧空闲，都返回GT_TRUE，即1），该函数在下面两个函数中被调用。
gt_bool SpsCheckSubCarriIdle(gt_u8 index){}

//从序号为0的子载波开始遍历g_gtSpsDlResourceData.data中第一个有空闲时域资源的子载波，并返回该子载波的序号。在下面的SpsSeizeRes()用到
gt_u8 SpsGetFirstIdleResIndex(){}

//和上面类似，只不过这里是从序号为cur的子载波开始。在下面的SpsSeizeRes()用到
gt_u8 SpsGetNextIdleResIndex(gt_u8 cur){}

//该函数用来将数组freq中第index/8个字节的第index%8个比特位置1。该函数在后面的函数中被调用，主要用来标记g_gtSpsDlLastFreq数组中已占用的频域资源，因为该数组的每个bit代表一个资源。
void SpsSetFreqRes(gt_u8 index, gt_u8 *freq){}

//和上面是对应的，上面是置，这里是获取
int SpsGetFreqRes(gt_u8 index, gt_u8 *freq){}

//和上上个函数是对应的，上上个函数是置1，这里是置0
void SpsClearFreqRes(gt_u8 index, gt_u8 *freq){}

//[.h] 判断g_gtSpsDlResourceData的carriIndex号子载波的frmIndex号无线帧是否可用，为1则不可用
gt_u8 SpsGetFrmRes(gt_u8 carriIndex, gt_u8 frmIndex){}

//更新已使用的子载波总量（+1），在下面的SpsDlSeizeResByCarriInfo()中和SpsDlReleaseResByCarriInfo中使用
void SpsAddUsedCarriCount(){g_gtSpsDlResourceData.usedCarriNum++;}

//和上面对应
void SpsDecUsedCarriCount(){g_gtSpsDlResourceData.usedCarriNum--;}

//[.h] 和上面对应，返回已使用的子载波数量，在下面的SpsSeizeRes()中使用，用来分配资源前判断该次分配是否导致已分配的资源（usedCarriNum和本次分配的子载波之和）占比超过阈值。（参见算法设计说明书4.2.1.1节）
gt_u8 SpsDlGetUsedCarriCount(){return g_gtSpsDlResourceData.usedCarriNum;}

// 暂时按48kHZ采样率 设置整个时域为 1 – TODO（通过采样率计算可用的时域资源）
void SpsCalcTimeResBySamplingRate(SamplingRate rate, GtFrmRes *res){}
	
//用来分配资源，资源信息存储在info中，subCarriNum表示需要多少个子载波，rate用来在调用SpsCalcTimeResBySamplingRate()时用，所以这个函数的整个过程就是：先根据subCarriNum判断能不能给你分配资源，不能就报错，能的话就从g_gtSpsDlResourceData中找subCarriNum个子载波给你用，同时还要通过SpsCalcTimeResBySamplingRate()函数来标记这些子载波上可用的时域资源。最终效果是将分配的资源标记到info中，返回值表示分配是否成功。该函数在SpsDlCalcRes中被调用
gt_u32 SpsSeizeRes(SamplingRate rate, gt_u8 subCarriNum, SpsUsedCarriInfo *info){}

// 计算帧配置下的g符号、t符号和控制符号的个数，标记？。他不是用来计算可用符号个数x的（在计算所需子载波时），他在下面的SpsDlCalcCostIndType2()中用到，用来表示可用时域信息。
gt_u8 SpsGetFrmDataSymbolInfo(){}

//用来计算半静态激活的DCI内容，尚未实现。本函数在下面的SpsDlCalcRes()中用到。
void SpsCalcActiveDci(DciSpsActive_60 *out){}

//[.h] 6.4.3.1　第二类数据信息传输开销资源指示信息，配置给costInd，配置的内容参见算法设计说明书中图4-8。本函数在上面的SpsDlRefreshType2ResInd()中被调用，用来配置第二类资源指示DCI，配置完后会进行发送
void SpsDlCalcCostIndType2(DciCostIndType2 *costInd){}

//把info中存储的所有已使用的子载波的序号标记到freq这个40bit的数组中去，比如子载波序号是index，就GT_SET_BIT(freq[index/8], index%8)
void SpsTranslateCarriInfoToFreq(SpsUsedCarriInfo *info, gt_u8 *freq){}

//[.h] 计算资源分配的结果（包括帧周期、子载波位置、TBSize、激活DCI信息等）到out中。该函数在同级目录下的gt_mac_dl_xrc.c文件中被调用。
gt_u32 SpsDlCalcRes(SpsInputParamType1 *param, SpsOutputParamType1 *out){}

//[.h] 配置去激活DCI，尚未实现。在外部文件中被使用
void SpsSetDciDeActive(DciSpsActive_60 *dci){}

//[.h] 返回已使用的频域信息。
gt_u8 *SpsDlGetFreqRes(){return g_gtSpsDlLastFreq;}

//[.h] 根据传入参数来（希望占用的时频域资源）在g_gtSpsDlResourceData中更新已占用的时域资源，并在g_gtSpsDlLastFreq中更新已占用的频域资源。该函数在上面的SpsSeizeRes()中被调用。
void SpsDlSeizeResByCarriInfo(SpsCarriInfo *carriInfo){}

//[.h] 与上相反，该函数在gt_mgm.c中被调用，用来清除T节点已使用的sps资源。
void SpsDlReleaseResByCarriInfo(SpsCarriInfo *carriInfo){}

//计算T节点是否有可用的DCI资源（参考算法设计说明书4.2.1的图4-4的注1，其中提到可能会因为DCI资源受限而导致下发激活DCI失败，所以这里要检查）。该函数在下面的SpsDlActiveDciMul()中在发送激活DCI之前被调用。
int SpsDlCalcTnodesActiveDciRes(gt_u16 *tNodeArray, gt_u8 size){}

//[.h] 获取所有调度的T节点，并向这些节点发送下行半静态激活DCI
void SpsDlActiveDciMul(){}

// 获取去激活节点集合, 这里模拟 1, 2 节点的去激活(TODO)（该函数被下面的SpsDlDeActiveDciMul()调用）
void SpsGetDeActiveNodes(gt_u16 **nodes, gt_u16 *len){}

//[.h] 发送去激活消息（不需要调用SpsDlCalcTnodesActiveDciRes，算法设计说明书的图4-4并没有说去激活DCI发送失败的处理）
void SpsDlDeActiveDciMul(){}

//设置g_gtSpsDlResourceData中的DC子载波下的所有无线帧的标志位为1，并将g_gtSpsDlLastFreq中的DC子载波的标志位置1。所以该函数的功能就是设置DC子载波为不可占用，该函数在下面的SpsDlInit()中被调用。
void SpsSetDcUsed(){}

//[.h] 可能还没写完。
void SpsDlInit(){SpsSetDcUsed();}

